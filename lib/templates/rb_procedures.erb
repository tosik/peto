require "peto/mixin/peto_class"
require "peto/mixin/peto_errorable"

module Peto
  <%- each_types do |name, args| -%>
  class <%= name %>
    include PetoClass
    def initialize(args={})
      <%- args.each do |arg| -%>
        <%- if arg[:array_type] -%>
      @<%= arg[:name] %> = [] # for <%= arg[:array_type] %>
        <%- else -%>
      @<%= arg[:name] %> = nil
        <%- end -%>
      <%- end -%>

      set_by_hash(args)
    end

    <%- args.each do |arg| -%>
    attr_reader :<%= arg[:name] %>
    <%- end -%>

    def members
      [<%= args.map{|arg| ":#{arg[:name]}"}.join(",") %>]
    end

    def types
      {<%= args.map{|arg| ":#{arg[:name]} => #{arg[:type]}"}.join(",") %>}
    end
  end
  <%- end -%>
end

module Peto
  class <%= class_name %>
    extend PetoErrorable
    <%- each_procedures do |name, args| -%>
    def self.<%= name %>(<%= args.map{|arg| arg[:name]}.join(",") %>)
      <%- args.each do |arg| -%>
      invalid_type("<%= arg[:name] %>", <%= arg[:type] %>, <%= arg[:name] %>) unless <%= arg[:name] %>.class == <%= arg[:type] %>
      <%- end -%>
      raise_errors unless errors.empty?

      return {
        :procedure => "<%=name%>",
	:args => {
          <%- args.each do |arg| -%>
          :<%=arg[:name]%> => hashize(<%=arg[:name]%>),
          <%- end -%>
        }
      }
    end

    <%- end -%>

    def self.hashize(var)
      return var if [Fixnum, String].include?(var.class)
      var.to_hash
    end
  end
end
